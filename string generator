import React, { useState, useRef, useEffect } from 'react';
import { Upload, Download, Settings, ImagePlus, Zap } from 'lucide-react';

const StringArtConverter = () => {
  const [image, setImage] = useState(null);
  const [processing, setProcessing] = useState(false);
  const [result, setResult] = useState(null);
  const [params, setParams] = useState({
    pegs: 200,
    lines: 3000,
    lineWeight: 0.2,
    frameShape: 'circle'
  });
  const [showSettings, setShowSettings] = useState(false);
  
  const canvasRef = useRef(null);
  const resultCanvasRef = useRef(null);
  const fileInputRef = useRef(null);

  const handleImageUpload = (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    
    if (file.type.startsWith('image/')) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          setImage(img);
          setResult(null); // Clear previous result
          setTimeout(() => drawOriginalImage(img), 0);
        };
        img.onerror = () => {
          alert('Failed to load image. Please try another file.');
        };
        img.src = event.target.result;
      };
      reader.onerror = () => {
        alert('Failed to read file. Please try again.');
      };
      reader.readAsDataURL(file);
    } else {
      alert('Please upload a valid image file (PNG, JPG, etc.)');
    }
  };

  const drawOriginalImage = (img) => {
    const canvas = canvasRef.current;
    if (!canvas || !img) return;
    
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const size = 500;
    canvas.width = size;
    canvas.height = size;
    
    // White background
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, size, size);
    
    // Calculate scaling to fit image
    const scale = Math.min(size / img.width, size / img.height);
    const x = (size - img.width * scale) / 2;
    const y = (size - img.height * scale) / 2;
    
    // Draw image centered
    ctx.drawImage(img, x, y, img.width * scale, img.height * scale);
  };

  const convertToGrayscale = (imageData) => {
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
      data[i] = avg;
      data[i + 1] = avg;
      data[i + 2] = avg;
    }
    return imageData;
  };

  const generatePegs = (numPegs, size, shape) => {
    const pegs = [];
    const centerX = size / 2;
    const centerY = size / 2;
    const radius = size / 2 - 20;
    
    if (shape === 'circle') {
      for (let i = 0; i < numPegs; i++) {
        const angle = (i / numPegs) * Math.PI * 2;
        pegs.push({
          x: centerX + radius * Math.cos(angle),
          y: centerY + radius * Math.sin(angle)
        });
      }
    } else {
      const perSide = Math.floor(numPegs / 4);
      for (let i = 0; i < perSide; i++) {
        pegs.push({ x: 20 + (size - 40) * (i / perSide), y: 20 });
      }
      for (let i = 0; i < perSide; i++) {
        pegs.push({ x: size - 20, y: 20 + (size - 40) * (i / perSide) });
      }
      for (let i = 0; i < perSide; i++) {
        pegs.push({ x: size - 20 - (size - 40) * (i / perSide), y: size - 20 });
      }
      for (let i = 0; i < perSide; i++) {
        pegs.push({ x: 20, y: size - 20 - (size - 40) * (i / perSide) });
      }
    }
    
    return pegs;
  };

  const getLinePixels = (x0, y0, x1, y1) => {
    const pixels = [];
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;

    let x = Math.round(x0);
    let y = Math.round(y0);

    while (true) {
      pixels.push({ x, y });
      
      if (x === Math.round(x1) && y === Math.round(y1)) break;
      
      const e2 = 2 * err;
      if (e2 > -dy) {
        err -= dy;
        x += sx;
      }
      if (e2 < dx) {
        err += dx;
        y += sy;
      }
    }
    
    return pixels;
  };

  const calculateLineScore = (pegs, pegA, pegB, imageData, size) => {
    const pixels = getLinePixels(pegs[pegA].x, pegs[pegA].y, pegs[pegB].x, pegs[pegB].y);
    let score = 0;
    
    for (const pixel of pixels) {
      const x = Math.round(pixel.x);
      const y = Math.round(pixel.y);
      
      if (x >= 0 && x < size && y >= 0 && y < size) {
        const idx = (y * size + x) * 4;
        const darkness = 255 - imageData.data[idx];
        score += darkness;
      }
    }
    
    return score / pixels.length;
  };

  const processImage = async () => {
    if (!image) return;
    
    setProcessing(true);
    
    setTimeout(() => {
      const size = 500;
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = size;
      tempCanvas.height = size;
      const tempCtx = tempCanvas.getContext('2d');
      
      tempCtx.fillStyle = '#ffffff';
      tempCtx.fillRect(0, 0, size, size);
      
      const scale = Math.min(size / image.width, size / image.height);
      const x = (size - image.width * scale) / 2;
      const y = (size - image.height * scale) / 2;
      
      tempCtx.drawImage(image, x, y, image.width * scale, image.height * scale);
      
      let imageData = tempCtx.getImageData(0, 0, size, size);
      imageData = convertToGrayscale(imageData);
      
      const pegs = generatePegs(params.pegs, size, params.frameShape);
      const lines = [];
      let currentPeg = 0;
      
      const resultCanvas = resultCanvasRef.current;
      resultCanvas.width = size;
      resultCanvas.height = size;
      const ctx = resultCanvas.getContext('2d');
      
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, size, size);
      ctx.strokeStyle = `rgba(0, 0, 0, ${params.lineWeight})`;
      ctx.lineWidth = 0.5;
      
      for (let line = 0; line < params.lines; line++) {
        let bestScore = -1;
        let bestPeg = -1;
        
        for (let nextPeg = 0; nextPeg < pegs.length; nextPeg++) {
          if (nextPeg === currentPeg) continue;
          if (lines.length > 0 && nextPeg === lines[lines.length - 1].to) continue;
          
          const score = calculateLineScore(pegs, currentPeg, nextPeg, imageData, size);
          
          if (score > bestScore) {
            bestScore = score;
            bestPeg = nextPeg;
          }
        }
        
        if (bestPeg === -1) break;
        
        lines.push({ from: currentPeg, to: bestPeg });
        
        ctx.beginPath();
        ctx.moveTo(pegs[currentPeg].x, pegs[currentPeg].y);
        ctx.lineTo(pegs[bestPeg].x, pegs[bestPeg].y);
        ctx.stroke();
        
        const linePixels = getLinePixels(
          pegs[currentPeg].x, 
          pegs[currentPeg].y, 
          pegs[bestPeg].x, 
          pegs[bestPeg].y
        );
        
        for (const pixel of linePixels) {
          const px = Math.round(pixel.x);
          const py = Math.round(pixel.y);
          
          if (px >= 0 && px < size && py >= 0 && py < size) {
            const idx = (py * size + px) * 4;
            imageData.data[idx] = Math.min(255, imageData.data[idx] + 20);
            imageData.data[idx + 1] = Math.min(255, imageData.data[idx + 1] + 20);
            imageData.data[idx + 2] = Math.min(255, imageData.data[idx + 2] + 20);
          }
        }
        
        currentPeg = bestPeg;
      }
      
      ctx.fillStyle = '#000';
      for (const peg of pegs) {
        ctx.beginPath();
        ctx.arc(peg.x, peg.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      setResult({ lines, pegs });
      setProcessing(false);
    }, 100);
  };

  const downloadInstructions = () => {
    if (!result) return;
    
    let instructions = `STRING ART INSTRUCTIONS\n\n`;
    instructions += `Frame: ${params.frameShape === 'circle' ? 'Circular' : 'Square'}\n`;
    instructions += `Number of Pegs: ${params.pegs}\n`;
    instructions += `Total Lines: ${result.lines.length}\n\n`;
    instructions += `STEP-BY-STEP GUIDE:\n\n`;
    
    result.lines.forEach((line, idx) => {
      instructions += `${idx + 1}. Connect peg ${line.from} to peg ${line.to}\n`;
    });
    
    const blob = new Blob([instructions], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'string-art-instructions.txt';
    a.click();
  };

  const downloadImage = () => {
    if (!resultCanvasRef.current) return;
    
    const url = resultCanvasRef.current.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'string-art-pattern.png';
    a.click();
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-8">
      <div className="max-w-7xl mx-auto">
        <div className="text-center mb-8">
          <h1 className="text-5xl font-bold text-white mb-3">String Art Converter</h1>
          <p className="text-purple-200 text-lg">Transform your photos into beautiful string art patterns</p>
        </div>

        <div className="grid md:grid-cols-2 gap-6">
          {/* Upload Section */}
          <div className="bg-white/10 backdrop-blur-lg rounded-2xl p-6 border border-white/20">
            <h2 className="text-2xl font-semibold text-white mb-4 flex items-center gap-2">
              <Upload className="w-6 h-6" />
              Original Image
            </h2>
            
            {!image ? (
              <label className="block border-2 border-dashed border-purple-300 rounded-xl p-12 text-center cursor-pointer hover:border-purple-400 transition-colors bg-white/5">
                <ImagePlus className="w-16 h-16 mx-auto mb-4 text-purple-300" />
                <p className="text-white text-lg mb-2">Click to upload image</p>
                <p className="text-purple-200 text-sm">PNG, JPG up to 10MB</p>
                <input
                  type="file"
                  accept="image/*"
                  onChange={handleImageUpload}
                  className="hidden"
                />
              </label>
            ) : (
              <div className="relative">
                <canvas
                  ref={canvasRef}
                  className="w-full rounded-xl border border-white/20"
                />
                <label className="mt-4 w-full px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white rounded-lg transition-colors cursor-pointer block text-center">
                  Change Image
                  <input
                    type="file"
                    accept="image/*"
                    onChange={handleImageUpload}
                    className="hidden"
                  />
                </label>
              </div>
            )}
            
            <input
              ref={fileInputRef}
              type="file"
              accept="image/*"
              onChange={handleImageUpload}
              className="hidden"
            />
          </div>

          {/* Result Section */}
          <div className="bg-white/10 backdrop-blur-lg rounded-2xl p-6 border border-white/20">
            <h2 className="text-2xl font-semibold text-white mb-4 flex items-center gap-2">
              <Zap className="w-6 h-6" />
              String Art Pattern
            </h2>
            
            {!result ? (
              <div className="border-2 border-white/20 rounded-xl p-12 text-center bg-white/5 h-[500px] flex items-center justify-center">
                <div>
                  <p className="text-purple-200 text-lg">Your string art will appear here</p>
                  {image && (
                    <button
                      onClick={processImage}
                      disabled={processing}
                      className="mt-6 px-8 py-3 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-lg font-semibold transition-all disabled:opacity-50"
                    >
                      {processing ? 'Processing...' : 'Generate String Art'}
                    </button>
                  )}
                </div>
              </div>
            ) : (
              <div>
                <canvas
                  ref={resultCanvasRef}
                  className="w-full rounded-xl border border-white/20"
                />
                <div className="flex gap-3 mt-4">
                  <button
                    onClick={downloadInstructions}
                    className="flex-1 px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg transition-colors flex items-center justify-center gap-2"
                  >
                    <Download className="w-4 h-4" />
                    Instructions
                  </button>
                  <button
                    onClick={downloadImage}
                    className="flex-1 px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors flex items-center justify-center gap-2"
                  >
                    <Download className="w-4 h-4" />
                    Pattern
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Settings Panel */}
        <div className="mt-6 bg-white/10 backdrop-blur-lg rounded-2xl p-6 border border-white/20">
          <button
            onClick={() => setShowSettings(!showSettings)}
            className="w-full flex items-center justify-between text-white text-xl font-semibold"
          >
            <span className="flex items-center gap-2">
              <Settings className="w-6 h-6" />
              Advanced Settings
            </span>
            <span className="text-2xl">{showSettings ? '−' : '+'}</span>
          </button>
          
          {showSettings && (
            <div className="mt-6 grid md:grid-cols-2 gap-6">
              <div>
                <label className="block text-purple-200 mb-2">Number of Pegs: {params.pegs}</label>
                <input
                  type="range"
                  min="50"
                  max="300"
                  value={params.pegs}
                  onChange={(e) => setParams({...params, pegs: parseInt(e.target.value)})}
                  className="w-full"
                />
              </div>
              
              <div>
                <label className="block text-purple-200 mb-2">Number of Lines: {params.lines}</label>
                <input
                  type="range"
                  min="500"
                  max="5000"
                  step="100"
                  value={params.lines}
                  onChange={(e) => setParams({...params, lines: parseInt(e.target.value)})}
                  className="w-full"
                />
              </div>
              
              <div>
                <label className="block text-purple-200 mb-2">Line Darkness: {params.lineWeight.toFixed(2)}</label>
                <input
                  type="range"
                  min="0.05"
                  max="0.5"
                  step="0.05"
                  value={params.lineWeight}
                  onChange={(e) => setParams({...params, lineWeight: parseFloat(e.target.value)})}
                  className="w-full"
                />
              </div>
              
              <div>
                <label className="block text-purple-200 mb-2">Frame Shape</label>
                <select
                  value={params.frameShape}
                  onChange={(e) => setParams({...params, frameShape: e.target.value})}
                  className="w-full px-4 py-2 rounded-lg bg-white/10 text-white border border-white/20"
                >
                  <option value="circle">Circle</option>
                  <option value="square">Square</option>
                </select>
              </div>
            </div>
          )}
        </div>

        {/* Info Section */}
        <div className="mt-6 bg-gradient-to-r from-purple-500/20 to-pink-500/20 backdrop-blur-lg rounded-2xl p-6 border border-purple-400/30">
          <h3 className="text-xl font-semibold text-white mb-3">How to Use</h3>
          <ol className="text-purple-100 space-y-2 list-decimal list-inside">
            <li>Upload your image (portraits and high-contrast images work best)</li>
            <li>Adjust settings to customize your pattern</li>
            <li>Click "Generate String Art" to create your pattern</li>
            <li>Download the instructions and pattern image</li>
            <li>Follow the numbered peg sequence to create your physical string art!</li>
          </ol>
        </div>
      </div>
    </div>
  );
};

export default StringArtConverter;